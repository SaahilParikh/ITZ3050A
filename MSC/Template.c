#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    powerExpander,  sensorNone)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  hangLock,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  liftBottom,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveRightFront, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port3,           liftRightEnc,  tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           liftLeftIn,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftRightTop,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           liftLeftTop,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftRightIn,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftLeftEnc,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          driveLeftFront, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//#include "definitions.h";
#include "functions.h";
#include "LCD.h";
#include "AutonMenu.h";
//Competition Control and Duration Setting
int count = 0;
bool auton = false;

task batteryLCD() {
	while(true) {
		bLCDBacklight = true;
		string mainBatteryStatus, backupBatteryStatus;
		sprintf(mainBatteryStatus,"Cortex: %1.2f%c V", nImmediateBatteryLevel/1000.0);
		sprintf(backupBatteryStatus,"Xpander: %1.2f%c V", SensorValue[powerExpander]/280.0);
		displayLCDString(0, 0, mainBatteryStatus);
		displayLCDString(1, 0, backupBatteryStatus);
		delay(30000);
	}
}




void autonChooser()
{
	int choice =0;
	int numberAutons = 10;




	while(nLCDButtons != 2) {
				centerLine(0,autonomousMenu[choice]);
				centerLine(1,"<-- SELECT -->");
				if(nLCDButtons == LCD_LEFT_BUTTON) {
					waitForRelease();
					choice = choice==0?numberAutons-1:choice-1;
				} else if(nLCDButtons == LCD_RIGHT_BUTTON) {
					waitForRelease();
					choice = choice==numberAutons-1?0:choice+1;
				}

				delay(100);
			}
			waitForRelease();
			count = choice;
			delay(50);

}


task doubleCheck()
	{
		while(bIfiRobotDisabled)
		{
			delay(5);
		}
		auton = true;
	}





//Wait for Press--------------------------------------------------

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	// bStopTasksBetweenModes = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Declare count variable to keep track of our choice
	//centerLine(1, "Team 3050A");
	//Loop while center button is not pressed

	while(!auton)
	{
		startTask(doubleCheck);
		if(bIfiRobotDisabled) // true is diabled false is enabled check this tmmr
		{
			//Switch case that allows the user to choose from 4 different options
			switch(count){
			case 0:
				//Display first choice
			//	clearLCDLine(0);
			//	clearLCDLine(1);
				CenterLine(0, "Auton  ||  ");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();

					autonChooser();
					CenterLine(0, "Auton  ||  ");
					centerLine(1,autonomousMenu[count]);
					writeDebugStream("%d%s\r\n",count,autonomousMenu[count]);

				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					//count = 100;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					preAutonBattery();

				}

				break;
			default:
				count = 099;
				break;

			}
		}
		else
		{
			auton = true;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Prog Skills");
		displayLCDCenteredString(1, "is running!");


		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	bLCDBacklight = true;									// Turn on LCD Backlight


	while (true)
	{

		clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD
		startTask(batteryLCD);

		//Display the Backup battery voltage


		wait1Msec(10);


	}
}
